<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Landing Page</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            font-family: 'Courier New', monospace;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }
        
        .grid-container {
            display: grid;
            gap: 2px;
            background: #000;
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        .cell {
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            color: #606060;
            background: #000;
            cursor: pointer;
            transition: color 0.1s ease;
            min-width: 0;
            min-height: 0;
            will-change: color, text-shadow, transform;
        }
        
        .center-block {
            color: #FFFFFF !important;
            font-style: italic;
            text-shadow: 0 0 10px #FFFFFF;
        }
        
        .cursor-highlight {
            transition: color 0.1s ease;
        }
        
        .highlighted {
            text-shadow: 0 0 5px currentColor;
        }

        /* Optimized animation classes for better performance */
        .ripple-wave {
            transform: scale(1.2) !important;
            transition: transform 0.15s cubic-bezier(0.25, 0.46, 0.45, 0.94) !important;
        }

        .ripple-fade {
            transition: color 0.3s ease-out, text-shadow 0.3s ease-out !important;
        }

        /* Proportional font scaling that maintains readability */
        @media (max-width: 480px) {
            .cell {
                font-size: clamp(8px, 2.5vw, 12px);
            }
            .grid-container {
                gap: 1px;
            }
        }

        @media (min-width: 481px) and (max-width: 768px) {
            .cell {
                font-size: clamp(10px, 1.8vw, 14px);
            }
            .grid-container {
                gap: 1px;
            }
        }

        @media (min-width: 769px) and (max-width: 1200px) {
            .cell {
                font-size: clamp(11px, 1.2vw, 14px);
            }
            .grid-container {
                gap: 2px;
            }
        }

        @media (min-width: 1201px) and (max-width: 1600px) {
            .cell {
                font-size: clamp(12px, 1vw, 16px);
            }
            .grid-container {
                gap: 2px;
            }
        }

        @media (min-width: 1601px) {
            .cell {
                font-size: 12px;
            }
            .grid-container {
                gap: 2px;
            }
        }
    </style>
</head>
<body>
    <div class="grid-container" id="grid"></div>

    <script>
        // Consistent proportional grid with better scaling
        function calculateGridDimensions() {
            const screenWidth = window.innerWidth;
            const screenHeight = window.innerHeight;
            
            let gridWidth, gridHeight;
            
            if (screenWidth <= 480) {
                // Mobile phones - proportionally smaller but readable
                gridWidth = Math.floor(screenWidth / 12);
                gridHeight = Math.floor(screenHeight / 16);
            } else if (screenWidth <= 768) {
                // Tablets - maintain proportion
                gridWidth = Math.floor(screenWidth / 14);
                gridHeight = Math.floor(screenHeight / 18);
            } else if (screenWidth <= 1200) {
                // Standard laptops - keep original feel
                gridWidth = Math.floor(screenWidth / 16);
                gridHeight = Math.floor(screenHeight / 20);
            } else if (screenWidth <= 1600) {
                // Large laptops/small desktops
                gridWidth = Math.floor(screenWidth / 18);
                gridHeight = Math.floor(screenHeight / 22);
            } else {
                // Large desktops - original dense look
                gridWidth = 120;
                gridHeight = 50;
            }
            
            // Ensure reasonable bounds
            gridWidth = Math.max(Math.min(gridWidth, 120), 20);
            gridHeight = Math.max(Math.min(gridHeight, 50), 25);
            
            return { gridWidth, gridHeight };
        }
        
        // Initialize responsive dimensions
        const dimensions = calculateGridDimensions();
        const gridWidth = dimensions.gridWidth;
        const gridHeight = dimensions.gridHeight;
        const totalCells = gridWidth * gridHeight;
        const centerRow = Math.floor(gridHeight / 2);
        const centerCol = Math.floor(gridWidth / 2);
        
        // Set responsive grid
        const grid = document.getElementById('grid');
        grid.style.gridTemplateColumns = `repeat(${gridWidth}, 1fr)`;
        grid.style.gridTemplateRows = `repeat(${gridHeight}, 1fr)`;
        
        // Control variables for flashing state
        let flashingIntervals = [];
        let isClickEffectActive = false;
        
        // Letters to include
        const hridayLetters = ['H', 'R', 'I', 'D', 'A', 'Y'];
        const allLetters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
        
        // Separate color arrays for different effects
        const flashingColors = [
            '#00BFFF', '#00FF00', '#FF1493', '#FF8C00',
            '#9400D3', '#FF0000', '#FFD700', '#00FFFF'
        ];
        
        const rippleColors = [
            '#00BFFF', '#00FF00', '#FF1493', '#FF8C00',
            '#9400D3', '#FF0000', '#FFD700', '#00FFFF'
        ];
        
        // Generate grid with alternating HRI/DAY rows
        function generateGrid() {
            const letters = [];
            
            for (let row = 0; row < gridHeight; row++) {
                for (let col = 0; col < gridWidth; col++) {
                    if (row % 2 === 0) {
                        const hriPattern = ['H', 'R', 'I'];
                        letters.push(hriPattern[col % 3]);
                    } else {
                        const dayPattern = ['D', 'A', 'Y'];
                        letters.push(dayPattern[col % 3]);
                    }
                }
            }
            
            return letters;
        }
        
        // Calculate distance between two grid positions
        function calculateDistance(row1, col1, row2, col2) {
            return Math.sqrt(Math.pow(row2 - row1, 2) + Math.pow(col2 - col1, 2));
        }
        
        // Select cells for flashing (no exclusion for "COMING SOON" anymore)
        function selectFlashingCells() {
            const excludedPositions = [];
            const centerStartCol = Math.floor(gridWidth / 2) - 1;
            const centerRowTop = Math.floor(gridHeight / 2) - 1;
            const centerRowBottom = Math.floor(gridHeight / 2);
            
            // Only exclude center HRIDAY block
            for (let col = centerStartCol; col <= centerStartCol + 2; col++) {
                if (col >= 0 && col < gridWidth) {
                    excludedPositions.push(centerRowTop * gridWidth + col);
                    excludedPositions.push(centerRowBottom * gridWidth + col);
                }
            }
            
            const availableCells = totalCells - excludedPositions.length;
            // Reduce flashing percentage on mobile for better performance
            const flashingPercentage = gridWidth < 30 ? 0.2 : 0.3;
            const numFlashing = Math.floor(availableCells * flashingPercentage);
            const positions = [];
            
            while (positions.length < numFlashing && positions.length < availableCells) {
                const pos = Math.floor(Math.random() * totalCells);
                if (!positions.includes(pos) && !excludedPositions.includes(pos)) {
                    positions.push(pos);
                }
            }
            
            return positions;
        }
        
        // Create the grid
        function createGrid() {
            const letters = generateGrid();
            
            for (let i = 0; i < totalCells; i++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.textContent = letters[i];
                cell.dataset.index = i;
                cell.dataset.originalColor = '#606060';
                
                const row = Math.floor(i / gridWidth);
                const col = i % gridWidth;
                const centerStartCol = Math.max(0, centerCol - 1);
                
                // Center HRIDAY block - ensure it fits on all screen sizes
                if ((row === centerRow - 1 && col >= centerStartCol && col <= Math.min(centerStartCol + 2, gridWidth - 1)) || 
                    (row === centerRow && col >= centerStartCol && col <= Math.min(centerStartCol + 2, gridWidth - 1))) {
                    cell.classList.add('center-block');
                    cell.dataset.originalColor = '#FFFFFF';
                    
                    if (row === centerRow - 1) {
                        if (col === centerStartCol) cell.textContent = 'H';
                        else if (col === centerStartCol + 1) cell.textContent = 'R';
                        else if (col === centerStartCol + 2) cell.textContent = 'I';
                    } else {
                        if (col === centerStartCol) cell.textContent = 'D';
                        else if (col === centerStartCol + 1) cell.textContent = 'A';
                        else if (col === centerStartCol + 2) cell.textContent = 'Y';
                    }
                }
                
                grid.appendChild(cell);
            }
        }
        
        // Function to clear all flashing intervals
        function clearAllFlashing() {
            flashingIntervals.forEach(interval => {
                clearInterval(interval);
                clearTimeout(interval);
            });
            flashingIntervals = [];
        }
        
        // Function to reset all cells to original gray state
        function resetAllCellsToOriginal() {
            const allCells = document.querySelectorAll('.cell');
            allCells.forEach(cell => {
                if (!cell.classList.contains('center-block')) {
                    cell.style.color = cell.dataset.originalColor;
                    cell.style.textShadow = 'none';
                    cell.style.transform = '';
                    cell.classList.remove('ripple-wave', 'ripple-fade');
                }
            });
        }
        
        // Modified flashing effect with performance optimization for mobile
        function addFlashingEffect() {
            clearAllFlashing();
            
            const flashingPositions = selectFlashingCells();
            const allCells = document.querySelectorAll('.cell');
            
            // Reduce animation frequency on smaller screens for better performance
            const animationMultiplier = gridWidth < 30 ? 1.5 : 1;
            
            flashingPositions.forEach(position => {
                const cell = allCells[position];
                if (cell && !cell.classList.contains('center-block')) {
                    const randomDelay = Math.random() * 5000 * animationMultiplier;
                    
                    const delayTimeout = setTimeout(() => {
                        if (!isClickEffectActive) {
                            const flashInterval = setInterval(() => {
                                if (!isClickEffectActive && Math.random() < 0.15) {
                                    const randomColor = flashingColors[Math.floor(Math.random() * flashingColors.length)];
                                    const originalColor = cell.dataset.originalColor;
                                    
                                    cell.style.color = randomColor;
                                    cell.style.textShadow = `0 0 5px ${randomColor}`;
                                    
                                    setTimeout(() => {
                                        if (!isClickEffectActive && cell.style.color === randomColor) {
                                            cell.style.color = originalColor;
                                            cell.style.textShadow = 'none';
                                        }
                                    }, 200 + Math.random() * 300);
                                }
                            }, (800 + Math.random() * 1200) * animationMultiplier);
                            
                            flashingIntervals.push(flashInterval);
                        }
                    }, randomDelay);
                    
                    flashingIntervals.push(delayTimeout);
                }
            });
        }
        
        // Click interaction with touch support and ripple effect
        function addClickInteraction() {
            const allCells = document.querySelectorAll('.cell');
            
            allCells.forEach(cell => {
                const index = parseInt(cell.dataset.index);
                const row = Math.floor(index / gridWidth);
                const col = index % gridWidth;
                const centerStartCol = Math.max(0, centerCol - 1);
                
                if ((row === centerRow - 1 && col >= centerStartCol && col <= Math.min(centerStartCol + 2, gridWidth - 1)) || 
                    (row === centerRow && col >= centerStartCol && col <= Math.min(centerStartCol + 2, gridWidth - 1))) {
                    
                    // Add both click and touch events for mobile compatibility
                    const handleInteraction = (event) => {
                        // Prevent double firing on mobile devices
                        event.preventDefault();
                        
                        // Debounce to prevent rapid multiple triggers
                        if (isClickEffectActive) return;
                        
                        isClickEffectActive = true;
                        clearAllFlashing();
                        resetAllCellsToOriginal();
                        
                        // Start ripple effect
                        createRippleEffect();
                    };
                    
                    cell.addEventListener('click', handleInteraction);
                    cell.addEventListener('touchstart', handleInteraction);
                }
            });
        }
        
        // Add double-click event to center HRIDAY block in og.html to redirect to test.html.
        function addDoubleClickToCenterBlock() {
            const allCells = document.querySelectorAll('.cell.center-block');

            allCells.forEach(cell => {
                let lastTap = 0;

                const handleTap = (event) => {
                    event.preventDefault();
                    const currentTime = new Date().getTime();
                    const tapLength = currentTime - lastTap;

                    if (tapLength < 400 && tapLength > 0) {
                        // Considered a double-tap
                        window.location.href = 'index.html';
                    }

                    lastTap = currentTime;
                };

                // Works for desktop and mobile
                cell.addEventListener('click', handleTap);
                cell.addEventListener('touchend', handleTap);
            });
        }
        
        // Create cumulative ripple effect from center
        function createRippleEffect() {
            const allCells = document.querySelectorAll('.cell');
            const rippleColor = rippleColors[Math.floor(Math.random() * rippleColors.length)];
            
            // Center position for ripple origin
            const centerStartCol = Math.max(0, centerCol - 1);
            const rippleCenterRow = centerRow - 0.5; // Between the two center rows
            const rippleCenterCol = centerStartCol + 1; // Middle of HRIDAY block
            
            // Group cells by distance from center
            const cellsByDistance = {};
            let maxDistance = 0;
            
            allCells.forEach((cell, index) => {
                if (!cell.classList.contains('center-block')) {
                    const row = Math.floor(index / gridWidth);
                    const col = index % gridWidth;
                    const distance = calculateDistance(rippleCenterRow, rippleCenterCol, row, col);
                    const roundedDistance = Math.floor(distance * 2) / 2; // Use half-integer steps for smoother effect
                    
                    maxDistance = Math.max(maxDistance, roundedDistance);
                    
                    if (!cellsByDistance[roundedDistance]) {
                        cellsByDistance[roundedDistance] = [];
                    }
                    cellsByDistance[roundedDistance].push({ cell, row, col });
                }
            });
            
            // Create cumulative wave effect - each distance ring animates in sequence but stays colored
            Object.keys(cellsByDistance).sort((a, b) => parseFloat(a) - parseFloat(b)).forEach(distance => {
                const cellsAtDistance = cellsByDistance[distance];
                const delay = parseFloat(distance) * 40; // 40ms delay per distance unit for smooth wave
                
                setTimeout(() => {
                    cellsAtDistance.forEach(({ cell }) => {
                        // Apply ripple color and pop effect
                        cell.style.color = rippleColor;
                        cell.style.textShadow = `0 0 10px ${rippleColor}`;
                        cell.classList.add('ripple-wave');
                        
                        // Remove pop effect but KEEP the color
                        setTimeout(() => {
                            cell.classList.remove('ripple-wave');
                            // Don't fade back to original - keep the ripple color!
                        }, 200);
                    });
                }, delay);
            });
            
            // Only fade everything back AFTER the ripple reaches the edges
            const totalRippleTime = maxDistance * 40 + 300;
            setTimeout(() => {
                // Now fade all colored cells back to original
                allCells.forEach(cell => {
                    if (!cell.classList.contains('center-block')) {
                        cell.classList.add('ripple-fade');
                        cell.style.color = cell.dataset.originalColor;
                        cell.style.textShadow = 'none';
                        
                        setTimeout(() => {
                            cell.classList.remove('ripple-fade');
                        }, 400);
                    }
                });
                
                // Reset effect state after fade completes
                setTimeout(() => {
                    isClickEffectActive = false;
                    setTimeout(() => {
                        addFlashingEffect();
                    }, 100);
                }, 500);
            }, totalRippleTime);
        }
        
        // Handle orientation changes
        function handleOrientationChange() {
            setTimeout(() => {
                location.reload();
            }, 100);
        }
        
        window.addEventListener('orientationchange', handleOrientationChange);
        window.addEventListener('resize', handleOrientationChange);
        
        // Initialize
        createGrid();
        setTimeout(() => {
            addFlashingEffect();
            addClickInteraction();
            addDoubleClickToCenterBlock();
        }, 500);
    </script>
</body>
</html>
